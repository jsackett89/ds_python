############################################################################################
# Simulate the sum generated by rolling fair dice
############################################################################################

# Function: i = number of dice, j = number of sides per die, k = number of iterations
show_me_the_money <- function(i, j, k) {
  # Initiate iterator variable
  iter <- 0
  # Create empty vector 'rolls_vec' to store the sum of the dice on each roll
  rolls_vec <<- vector('numeric')
  # Loop to perform simuation
  while (iter < k) {
    roll <- sample(1:j, i, replace = TRUE)
    rolls_vec <<- append(rolls_vec, sum(roll))
    iter <- iter + 1
  }
  # Percentage of each sum
  print(table(rolls_vec) / k * 100)
  # Expected sum
  exp_value <- sum(rolls_vec) / k
  print(paste('Expected sum:', exp_value))
  # Barplot of rolls
  barplot(table(rolls_vec), xlab = 'Sum of dice', ylab = 'Count', main = 'Distribution of sums')
}

############################################################################################
# Drawing random numbers until a given sum is reached
############################################################################################

# Function: a = lower limit for sampling, b = upper limit for sampling,
# c = desired sum, k = number of iterations
rand_sum <- function(a, b, c, k) {
  # Initiate iterator variable
  iter <- 0
  # Create empty vector 'count_vec' to store the number of samples required to reach given sum
  count_vec <<- vector('numeric')
  ## Loop to perform simulation
  while (iter < k) {
    x <- as.vector(runif(1, a, b))
    while (sum(x) <= c) {
      x <- append(x, runif(1, a, b))
    }
    count_vec <<- append(count_vec, length(x))
    iter <- iter + 1
  }
  # Percentage of each sum
  print(table(count_vec) / k * 100)
  # Expected value calculation
  exp_value <- sum(count_vec) / k
  print(paste('Expected number of draws required:', exp_value))
  # Barplot of rolls
  barplot(table(count_vec), xlab = 'Number of draws required', ylab = 'Count', main = 'Distribution')
}


############################################################################################
# Estimate the value of a definite integral                                                                                   
############################################################################################ 

# Function: f = function as a string conforming to R arithmetic conventions,
# a = lower bound, b = upper bound, k = number of iterations
def_integral <- function(f, a, b, k){
  # Initiate iterator variable
  iter <- 0
  # Create empty numeric vector 'under_curve' to store whether or not
  # each randomly-generated point is under the given function
  under_curve <<- vector('integer')
  # Create mathematical function from input
  fun <<- as.function(alist(x = , eval(parse(text = f))))
  # Calculate min and max of the function over the range [a, b]
  min_y <- optimize(fun, lower = a, upper = b)[[2]]
  max_y <- optimize(fun, lower = a, upper = b, maximum = TRUE)[[2]]
  # Determine area of the circumscribed rectangle
  rect_area <- (b - a) * (max_y - min_y)
  # Loop to construct under_curve vector. Analogous to acceptance/rejection sampling.
  while (iter < k) {
    # Draw two uniform random numbers of given domain and range
    x_0 <- runif(1, a, b)
    y_0 <- runif(1, min_y, max_y)
    # For accepted positive values, append a '1' to under_curve
    if (y_0 > 0) {
      if (y_0 <= fun(x_0)) {
        under_curve <<- append(under_curve, 1)
      } else {
        under_curve <<- append(under_curve, 0)
      }
    # For accepted negative values, append a '-1' to under_curve  
    } else if (y_0 < 0) {
        if (y_0 >= fun(x_0)) {
          under_curve <<- append(under_curve, -1)
        } else {
          under_curve <<- append(under_curve, 0)
        }
    # Otherwise, append a '0' to under_curve  
    } else {
        under_curve <<- append(under_curve, 0)
    }
    # Increment iterator
    iter <- iter + 1
  }
  # Print estimated area
  print(paste('Area:', sum(under_curve) / k * rect_area))
}
